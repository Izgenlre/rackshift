insert into template
values (uuid(), 'set_bmc_credentials.sh',
        '#!/usr/bin/env bash\n\n# Copyright 2016-2018, DELL EMC, Inc.\n\nchannel=''''\nfunction set_channel()\n\{\n    for i in \{1..15\}; do\n        ipmitool user list \$i &>/dev/null\n        status=\$?\n        if [ \"\$status\" -eq \"0\" ] ; then\n            channel=\$i\n            break\n        fi\n    done\n\}\nset_channel\necho \"channel number is\" \$channel\nif [ -z \"\$\{channel\}\" ]; then\n echo \"Channel number was not set correctly, exiting script\"\nexit 1\nfi\necho \" Getting the user list\"\ncmdReturn=\$(ipmitool user list \$channel)\nmyarray=(\$\{cmdReturn//\$''\\n''/ \})\nmapfile -t userlist < <(ipmitool user list \$channel)\nuserNumber=\$\{#userlist[@]\}\nif [ \"\$userNumber\" -gt  \"1\" ]; then\n   userNumber=\$(expr \$userNumber - 1)\nfi\n\n#The check variable is a flag to determine if the user already exists\n#(1:already exist and 0:user does not exist)\ncheck=0\n#The i variable is an index to determine the userID from the cmdReturn(userList)\ni=0\n#UserID used for adding new user\nnewUserNumber=0\n\nfor x in \$cmdReturn; do\n   if [ <%=user%> == \$x ]; then\n   userNumber=\$\{myarray[\$((\$i-1))]\}\n   echo \"Username already present, overwriting existing user\"\n   ipmitool user set name \$userNumber <%=user%>\n   ipmitool user set password \$userNumber <%-password%>\n   ipmitool channel setaccess \$channel \$userNumber callin=on ipmi=on link=on privilege=4\n   ipmitool user enable \$userNumber\n   check=\$((check + 1))\n  exit\n  fi\n  i=\$((i+1))\ndone\n\nfunction get_newUserNumber()\n\{\n  cmdReturn=\$(sudo ipmitool user summary \$channel)\n  myarray=(\$\{cmdReturn//\$''\\n''/ \})\n  maxCount=\$\{myarray[3]\}\n  if [ \$userNumber -lt \$maxCount ]; then\n    #try to find out the empty user id\n    maxLength=\$\{#userlist[@]\}\n    for ((i=1;i<\$maxLength;i++)) do\n      id=`echo \$\{userlist[i]\} | awk ''\{print \$1\}''`\n      if [ \$id != \$i ]; then\n        newUserNumber=\$i\n        break\n      fi\n    done\n    if [ \$newUserNumber -eq 0 ]; then\n      newUserNumber=\$((userNumber + 1))\n    fi\n  else\n    echo ''reach max user count''\n    exit 1\n  fi\n\}\n\nif [ \$check == 0 ]; then\n echo \"Creating a new user\"\n get_newUserNumber\n ipmitool user set name \$newUserNumber <%=user%>\n ipmitool user set password \$newUserNumber <%-password%>\n ipmitool channel setaccess \$channel \$newUserNumber callin=on ipmi=on link=on privilege=4\n ipmitool user enable \$newUserNumber\nexit\nfi\necho \"Done\"\n',
        'system', 1629698788504, 1629698788504);


insert into profile
values (uuid(), 'install-esx.ipxe',
        '# The progress notification is just something nice-to-have, so progress notification failure should\n# never impact the normal installation process\n<% if( typeof progressMilestones !== \''undefined\'' && progressMilestones.enterProfileUri ) \{ %>\n    # since there is no curl like http client in ipxe, so use imgfetch instead\n    # note: the progress milestones uri must be wrapped in unescaped format, otherwise imgfetch will fail\n    imgfetch --name fakedimage http://<%=server%>:<%=port%><%-progressMilestones.enterProfileUri%> ||\n    imgfree fakedimage ||\n<% \} %>\n\niseq $\{platform\} efi && goto is_efi || goto not_efi\n\n:not_efi\nkernel <%=repo%>/<%=mbootFile%> -c <%=esxBootConfigTemplateUri%> BOOTIF=01-$\{netX/mac\}\ngoto boot_img\n\n:is_efi\nkernel <%=repo%>/efi/boot/bootx64.efi -c <%=esxBootConfigTemplateUri%>\ngoto boot_img\n\n:boot_img\n<% if( typeof progressMilestones !== \''undefined\'' && progressMilestones.startInstallerUri ) \{ %>\n    imgfetch --name fakedimage http://<%=server%>:<%=port%><%-progressMilestones.startInstallerUri%> ||\n    imgfree fakedimage ||\n<% \} %>\n\nboot\n',
        'system', 1629698788504, 1629698788504);

insert into template
values (uuid(), 'esx-ks',
        'accepteula\n<!-- # Copyright 2016-2018, Dell EMC, Inc. -->\n<% if (typeof clearDisk === \''undefined\'') \{ %>\n<%   clearDisk = installDisk %>\n<% \} %>\n\n<% if (clearDisk === \''firstdisk\'') \{ %>\n  clearpart --firstdisk --overwritevmfs\n<% \} else if (clearDisk === \''alldrives\'') \{ %>\n  clearpart --alldrives --overwritevmfs\n<% \} else \{ %>\n  clearpart --drives=<%=clearDisk%> --overwritevmfs\n<% \} %>\n\n<% if (installDisk === \"firstdisk\") \{ %>\n  install --firstdisk --overwritevmfs\n<% \} else \{ %>\n  install --disk=<%=installDisk%> --overwritevmfs\n<% \} %>\nrootpw <%-rootPlainPassword%>\n\n# Search the networkDevices and set the first device (if defined) up.\n# Use kargs if set to override the default kickstart network device\n# If no device is specified in the networkDevices, then we fallback\n# to setting \''vmnic0\'' up as DHCP. The device can be specified with a\n# MAC address or device name (\''vmnic0\'' for example)\n<% if(Object.keys(kargs).length === 0) \{ %>\n<% if( typeof networkDevices !== \''undefined\'' ) \{ %>\n  <% need_default = networkDevices.every(function(n) \{ %>\n    <% if(typeof n.ipv4 !== \''undefined\'') \{ %>\n      <% ipopts = \''--ip=\'' + n.ipv4.ipAddr + \'' --gateway=\'' + n.ipv4.gateway + \'' --netmask=\'' + n.ipv4.netmask %>\n      <% if (typeof n.ipv4.vlanIds !== \''undefined\'' ) \{ %>\n        <% ipopts += \'' --vlanid=\'' + n.ipv4.vlanIds[0] %>\n      <% \} %>\n      network --bootproto=static --device=<%=n.device%> <%=ipopts%>\n    <% \} else \{ %>\n      network --bootproto=dhcp --device=<%=n.device%>\n    <% \} %>\n    <% return false; %>\n  <% \}); %>\n  <% if (need_default) \{ %>\n    network --bootproto=dhcp --device=vmnic0\n  <% \} %>\n<% \} %>\n<% \} %>\n\nreboot\n\n%firstboot --interpreter=busybox\n\n<% if( typeof progressMilestones !== \''undefined\'' && progressMilestones.firstBootUri ) \{ %>\n    wget \"http://<%=server%>:<%=port%><%-progressMilestones.firstBootUri%>\" || true\n<% \} %>\n\n# enable VHV (Virtual Hardware Virtualization to run nested 64bit Guests + Hyper-V VM)\ngrep -i \"vhv.enable\" /etc/vmware/config || echo \"vhv.enable = \\\"TRUE\\\"\" >> /etc/vmware/config\n\nvim-cmd hostsvc/enable_ssh\nvim-cmd hostsvc/start_ssh\nvim-cmd hostsvc/enable_esx_shell\nvim-cmd hostsvc/start_esx_shell\n\n#suppress shell warnings\nesxcli system settings advanced set -o /UserVars/SuppressShellWarning -i 1\n\n#Set the ESXi Shell Interactive idle time logout\nesxcli system settings advanced set -o /UserVars/ESXiShellInteractiveTimeout -i 3600\n\n#Set Console port redirect\nesxcli system settings kernel set -s=\"gdbPort\" -v=<%=gdbPort%>\nesxcli system settings kernel set -s=\"logPort\" -v=<%=logPort%>\nesxcli system settings kernel set -s=\"tty2Port\" -v=<%=comport%>\nesxcli system settings kernel set -s=\"debugLogToSerial\" -v=<%=debugLogToSerial%>\n\n# disable firewall\nesxcli network firewall set --default-action false --enabled no\n\n# set hostname and domain\n<% var hostnameCmdStr=\''\''; %>\n<% if (typeof domain === \''string\'') hostnameCmdStr += (\'' --domain \'' + domain) %>\n<% if (typeof hostname === \''string\'') hostnameCmdStr += (\'' --host \'' + hostname) %>\n<% if (typeof fqdn === \''string\'') hostnameCmdStr += (\'' --fqdn \'' + fqdn) %>\n<% if (hostnameCmdStr.length > 0) \{ %>\n    esxcli system hostname set <%=hostnameCmdStr%>\n<% \} %>\n\n#config root account\n<% if (typeof rootSshKey !== \''undefined\'') \{ %>\n    echo <%=rootSshKey%> > /etc/ssh/keys-root/authorized_keys\n<%\} %>\n\n#create users\nrm /vmfs/volumes/datastore1/rackhd_create_sshkeys\n<% if( typeof users !== \''undefined\'' ) \{ %>\n<% users.forEach(function(user) \{ %>\n    /usr/lib/vmware/auth/bin/adduser -s /bin/sh -G root -h / -D <%=user.name%>\n    echo <%-user.plainPassword%> | passwd <%=user.name%> --stdin\n    <% if (typeof user.sshKey !== \''undefined\'') \{ %>\n        echo \"mkdir /etc/ssh/keys-<%=user.name%>\" >> /vmfs/volumes/datastore1/rackhd_create_sshkeys\n        echo \"echo <%=user.sshKey%> > /etc/ssh/keys-<%=user.name%>/authorized_keys\" >> /vmfs/volumes/datastore1/rackhd_create_sshkeys\n    <%\} %>\n<%\}) %>\n<%\} %>\nchmod +x /vmfs/volumes/datastore1/rackhd_create_sshkeys\n\n#setup ntp\ncat > /etc/ntp.conf << __NTP_CONFIG__\nrestrict default kod nomodify notrap noquerynopeer\nrestrict 127.0.0.1 kkl,lkl\n<% if( typeof ntpServers !== \''undefined\'' ) \{ %>\n   <% ntpServers.forEach(function(ntp) \{ %>\n      server <%= ntp %>\n   <% \}); %>\n<% \} %>\n__NTP_CONFIG__\n/sbin/chkconfig ntpd on\n\n#enter maintenance mode\nesxcli system maintenanceMode set -e true\n\n#copy the first boot logs\ncp /var/log/hostd.log \"/vmfs/volumes/datastore1/firstboot-hostd.log\"\ncp /var/log/esxi_install.log \"/vmfs/volumes/datastore1/firstboot-esxi_install.log\"\n\n#setup DNS\n<% if( typeof dnsServers !== \''undefined\'' ) \{ %>\n  <% if ( typeof domain !== \''undefined\'' ) \{ %>\n  esxcli network ip dns search add --domain=<%=domain%>\n  <% \} %>\n  <% dnsServers.forEach(function(dns) \{ %>\n    esxcli network ip dns server add --server=<%= dns %>\n  <% \}); %>\n<% \} %>\n\n#create vSwitches with uplinks. An uplink can be specifed with its MAC\n#address or device name\n<% if ( typeof switchDevices !== \''undefined\'' ) \{ %>\n  <% switchDevices.forEach(function(n) \{ %>\n    esxcli network vswitch standard add -v \"<%=n.switchName%>\"\n    <% if( typeof n.failoverPolicy !== \''undefined\'' ) \{ %>\n        esxcli network vswitch standard policy failover set -l \"<%=n.failoverPolicy%>\" -v \"<%=n.switchName%>\"\n    <% \} %>\n    <% if( undefined !== n.uplinks ) \{ %>\n      <% n.uplinks.forEach(function(s) \{ %>\n        currdev=<%=s%>\n        <% if (s.substring(0,5) !== \''vmnic\'') \{ %>\n          currdev=`esxcli network nic list | grep <%=s%> | cut -d \'' \'' -f 1`\n        <% \} %>\n        currsw=`esxcli --debug --formatter=csv network vswitch standard list | grep $currdev | awk -F, \''\{print $9\}\''`\n        if [ \"$currsw\" != \"\" ]; then\n          esxcli network vswitch standard uplink remove -v $currsw -u $currdev\n        fi\n        esxcli network vswitch standard uplink add -v <%=n.switchName%> -u $currdev\n      <% \}); %>\n    <% \} %>\n  <% \}); %>\n<% \} %>\n\n#parameters:vmkName, portgroup, switchName\ncreateVmk () \{\n    vmkMac=`esxcli network ip interface list | sed -ne \''/^.*\\Name: $1.*$/\{N;s/.*MAC Address: //;p\}\''`\n    esxcli network vswitch standard portgroup add -p $2 -v $3\n    esxcli network ip interface remove -i $1\n    if [ -z $vmkMac ]\n    then\n      esxcli network ip interface add -i $1 -p $2\n    else\n      esxcli network ip interface add -i $1 -p $2 -M $vmkMac\n    fi\n\}\n\n<% vmkid = 0 %>\n<% if( typeof networkDevices !== \''undefined\'' ) \{ %>\n  <% networkDevices.forEach(function(n) \{ %>\n    currdev=<%=n.device%>\n    esxSwitchName=<%= typeof n.esxSwitchName!=\''undefined\'' ? n.esxSwitchName : \''vSwitch0\'' %>\n    <% if (n.device.substring(0,5) != \''vmnic\'') \{ %>\n       currdev=`esxcli network nic list | grep <%=n.device%> | cut -d \'' \'' -f 1`\n    <% \} %>\n    <% if( undefined !== n.ipv4 ) \{ %>\n      <% if( undefined !== n.ipv4.vlanIds ) \{ %>\n        <% n.ipv4.vlanIds.forEach(function(vid) \{ %>\n          <% vmkname = \''vmk\'' + vmkid++ %>\n          createVmk <%=vmkname%> $currdev.<%=vid%> $esxSwitchName\n          esxcli network ip interface ipv4 set -i <%=vmkname%> -I <%=n.ipv4.ipAddr%> -N <%=n.ipv4.netmask%> -t static\n          esxcli network ip route ipv4 add -n default -g <%=n.ipv4.gateway%>\n          esxcli network vswitch standard portgroup set -p $currdev.<%=vid%> -v <%=vid %>\n        <% \}); %>\n      <% \} else \{ %>\n        <% vmkname = \''vmk\'' + vmkid++ %>\n        createVmk <%=vmkname%> $currdev $esxSwitchName\n        esxcli network ip interface ipv4 set -i <%=vmkname%> -I <%=n.ipv4.ipAddr%> -N <%=n.ipv4.netmask%> -t static\n        esxcli network ip route ipv4 add -n default -g <%=n.ipv4.gateway%>\n      <% \} %>\n    <% \} %>\n    <% if( undefined !== n.ipv6 ) \{ %>\n      <% if( undefined !== n.ipv6.vlanIds ) \{ %>\n        <% n.ipv6.vlanIds.forEach(function(vid) \{ %>\n          <% vmkname = \''vmk\'' + vmkid++ %>\n          createVmk <%=vmkname%> $currdev.<%=vid%> $esxSwitchName\n          esxcli network ip interface ipv6 address add -i <%=vmkname%> -I <%=n.ipv6.ipAddr%>/<%=n.ipv6.prefixlen%>\n          <% if(undefined !== n.ipv6.gateway) \{ %>\n          esxcli network interface ipv6 set -i <%=vmkname%> -d off -r off\n          esxcli network ip interface ipv6 set -i <%=vmkname%> -g <%=n.ipv6.gateway%>\n          <% \} %>\n          esxcli network vswitch standard portgroup set -p $currdev.<%=vid%> -v <%=vid %>\n        <% \}); %>\n      <% \} else \{ %>\n        <% vmkname = \''vmk\'' + vmkid++ %>\n        createVmk <%=vmkname%> $currdev $esxSwitchName\n        esxcli network ip interface ipv6 address add -i <%=vmkname%> -I <%=n.ipv6.ipAddr%>/<%=n.ipv6.prefixlen%>\n        esxcli network ip interface ipv6 set -i <%=vmkname%> -g <%=n.ipv6.gateway%>\n      <% \} %>\n    <% \} %>\n    <% if( (undefined === n.ipv6) && (undefined === n.ipv4) ) \{ %>\n      <% vmkname = \''vmk\'' + vmkid++ %>\n      createVmk <%=vmkname%> $currdev $esxSwitchName\n      esxcli network ip interface ipv4 set -i <%=vmkname%> -t dhcp\n    <% \} %>\n  <% \}); %>\n<% \} %>\n\n<% if( typeof postInstallCommands !== \''undefined\'' ) \{ %>\n  <% postInstallCommands.forEach(function(n) \{ %>\n    <%-n%>\n  <% \}); %>\n<% \} %>\n\n# Download the service to callback to RackShift after OS installation/reboot completion\n# %firstboot ends with a reboot, this script will run afterwards to signify completion\n# of the installer and all reboot steps.\n#\n# The approved method for adding startup commands is to write to /etc/rc.local.d/local.sh,\n# which is a pre-existing file with a sticky bit set by VisorFS. You can\''t just create new\n# files and expect them to stick around, even if you set a sticky bit yourself.\n# The /sbin/auto-backup.sh script will ensure the changes are persisted across reboots and\n# MUST be executed after making any changes.\n#\n# See these links for more information:\n# http://www.virtuallyghetto.com/2011/08/how-to-persist-configuration-changes-in.html\n# http://blogs.vmware.com/vsphere/2011/09/how-often-does-esxi-write-to-the-boot-disk.html\n# https://communities.vmware.com/message/1273849#1273849\n#\n# NOTE: this method only works for ESXi 5.1 or greater. For older versions, the changes\n# must be written to /etc/rc.local instead.\n#\n# NOTE: this script will execute right away as a result of writing it to local.sh\n# along with executing on every subsequent boot\n#\n# Try to download call back script 60 times 1 second\n# sleep in between to allow link to be up after DHCP\nfor retry in $(seq 1 60);\ndo\n    wget http://<%=server%>:<%=port%>/api/current/templates/<%=rackhdCallbackScript%>?nodeId=<%=nodeId%> -O /etc/rc.local.d/local.sh\n    if [ $? -eq 0 ]; then\n        logger -p user.info \"RackHD\''s call back script was downloaded successfully after $retry attempt(s).\"\n        break\n    else\n        logger -p user.info \"Failed to download RackHD\''s call back script after $retry attempt(s).\"\n        sleep 1\n    fi\ndone;\n\nif [ $retry -eq 60 ]; then\n   logger -p user.err \"RackHD\''s call back script was not downloaded successfully.\"\nfi\n\n#backup ESXi configuration to persist it\n/sbin/auto-backup.sh\n\n#reboot the system after host configuration\nesxcli system shutdown reboot -d 10 -r \"Rebooting after first boot host configuration\"\n\n%pre --interpreter=busybox\n\n#notify the current progress\n<% if( typeof progressMilestones !== \''undefined\'' && progressMilestones.preConfigUri ) \{ %>\n    # the url may contain query, the symbol \''&\'' will mess the command line logic, so the whole url need be wrapped in quotation marks\n    wget \"http://<%=server%>:<%=port%><%-progressMilestones.preConfigUri%>\" || true\n<% \} %>\n\n\n%post --interpreter=busybox\n\n#notify the current progress\n<% if( typeof progressMilestones !== \''undefined\'' && progressMilestones.postConfigUri ) \{ %>\n    # the url may contain query, the symbol \''&\'' will mess the command line logic, so the whole url need be wrapped in quotation marks\n    wget \"http://<%=server%>:<%=port%><%-progressMilestones.postConfigUri%>\" || true\n<% \} %>\n\n#disable firewall\nlocalcli network firewall set --enabled no\n#signify ORA the installation completed\nBODY=\"\{\"\nBODY=$BODY\"\\\"nodeId\\\": \\\"<%=nodeId%>\\\"\"\nBODY=$BODY\"\}\"\nBODYLEN=$(echo -n $\{BODY\} | wc -c)\necho -ne \"POST /api/current/notification HTTP/1.0\\r\\nHost: <%=server%>\\r\\nContent-Type: application/json\\r\\nContent-Length: $\{BODYLEN\}\\r\\n\\r\\n$\{BODY\}\" | nc -i 3 <%=server%> <%=port%>\n',
        'system', 1629698788504, 1629698788504);

insert into template
values (uuid(), 'esx-boot-cfg',
        'bootstate=0\ntitle=Loading ESXi installer\nprefix=<%=repo%>\nkernel=<%=tbootFile%>\nkernelopt=runweasel formatwithmbr com1_baud=115200 com1_Port=<%=comportaddress%> tty2Port=<%=comport%> gdbPort=<%=gdbPort%> debugLogToSerial=<%=debugLogToSerial%> logPort=<%=logPort%> ks=<%=installScriptUri%>\nmodules=<%=moduleFiles%> <%=kargs%>\nbuild=\nupdated=0\n',
        'system', 1629698788504, 1629698788504);

insert into template
values (uuid(), 'esx.rackhdcallback',
        '#!/bin/sh\n# esx       callback to rackhd post installation API hook\n# description: calls back to rackhd post installation API hook\n\necho \"Attempting to call back to RackHD ESX installer\"\nLOCALSH=/etc/rc.local.d/local.sh\n# *sigh*, busybox shell does not support \{1..30\}. Retry 30 times with 1 second\n# sleep in between.\nfor retry in $(awk \''BEGIN \{ for ( i=0; i<30; i++ ) \{ print i; \} \}\'');\ndo\n    BODY=\"\{\"\n    BODY=$BODY\"\\\"nodeId\\\": \\\"<%=nodeId%>\\\"\"\n    BODY=$BODY\"\}\"\n    BODYLEN=$(echo -n $\{BODY\} | wc -c)\n    echo -ne \"POST /api/current/notification HTTP/1.0\\r\\nHost: <%=server%>\\r\\nContent-Type: application/json\\r\\nContent-Length: $\{BODYLEN\}\\r\\n\\r\\n$\{BODY\}\" | nc -i 3 <%=server%> <%=port%>\n    if [ \"$?\" -ne 0 ];\n    then\n        echo \"Failed to connect to RackHD API callback, retrying\"\n        sleep 1\n    else\n        if [ -e /vmfs/volumes/datastore1/rackhd_callback ]\n        then\n            echo \"Remove RackHD callback script\"\n            rm /vmfs/volumes/datastore1/rackhd_callback\n            echo \"Create RackHD SSH keys for non-root users after second reboot and on startup\"\n            /vmfs/volumes/datastore1/rackhd_create_sshkeys\n            echo \''#!/bin/sh\'' > $LOCALSH\n            cat /vmfs/volumes/datastore1/rackhd_create_sshkeys >> $LOCALSH\n            echo \''exit 0\'' >> $LOCALSH\n            /sbin/auto-backup.sh\n        else\n            touch /vmfs/volumes/datastore1/rackhd_callback\n        fi\n        exit 0\n    fi\ndone;\n\necho \"Exceeded retries connecting to RackHD API callback. Exiting with failure code 1\"\nexit 1\n',
        'system', 1629698788504, 1629698788504);

insert into system_parameter
values ('bmc_credentials', 'true', 'text', null);
insert into system_parameter
values ('bmc_username', 'rackshift', 'text', null);
insert into system_parameter
values ('bmc_password', 'rackshift', 'text', null);